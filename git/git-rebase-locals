#!/bin/zsh

# Rebase all local only branches on origin/master.

abort=0
ignore=(\*.bak \*.add)
upstream=origin/master
cmd=
verbose=0
retry=0

usage () {
  local prog="git ${${0##*/}#git-}"
  echo "$prog [-anx] [-i pattern] [-u upstream] [-- git-rebase(1) options]"
  echo "$prog -h"
}

help () {
  cat <<EOF

Rebase all local branches on the same upstream branch.  Branches that have a
remote tracking branch are ignored as are branches matching the ignore
patterns.

Options:
-a		abort a rabase that fails (and continue with the next one)
-n		just print what would be done, don't so anything
-x		give shell debuging output
-i pattern	add pattern to the list of ignore patterns, give the empty
		string as an argument to clear the list (default is *.bak,
		*.add)
-u upstream	set the upstream branch for the rebase (default is
		origin/master)
-r 		use git-retry-rebase to retry a rebase that failed (impies -a)

Everything after "--" will be passed to git-rebase(1) as options.
EOF
}

check-pattern-list () {
  # $1 an array name, the array should contain patterns
  # $2 a string to test against every pattern in turn
  # returns 0 if any pattern matches, 1 otherwise
  local pattern
  for pattern in ${(P)1}; do
    if [[ $2 = ${~pattern} ]]; then
      return 0
    fi
  done
  return 1
}

trap_handler () {
  trap - INT STOP HUP
  echo Caught signal.  Aborting all pending rebases. >&2
  git rebase --abort &>/dev/null
  return $((128 + $1))
}

# Parse the command line.
while getopts ahi:nru:vx FLAG; do
  case $FLAG in
    a) abort=1;;
    h) usage; help; exit;;
    i) if [[ -z $OPTARG ]]; then ignore=(); else ignore+=$OPTARG; fi;;
    n) cmd=echo;;
    r) retry=1 abort=1;;
    u) upstream=$OPTARG;;
    v) verbose=1;;
    x) set -x;;
    ?) usage; exit 2;;
  esac
done
shift $(($OPTIND-1))

if ((retry)) && ! [[ -x =git-retry-rebase ]]; then
  echo git-retry-rebase is not available. >&2
  retry=0
fi

# Populate the branches array.
branches=()
for branch in $(git branch | cut -c 3-); do
  if check-pattern-list ignore $branch; then
    # The branch should be ignored.
    continue
  elif git config --get branch.$branch.remote &>/dev/null; then
    # The branch has a remote tracking branch.
    continue
  else
    branches+=$branch
  fi
done

# Save the current HEAD.
head=$(git rev-parse --abbrev-ref HEAD)

# Set up the trap.
trap trap_handler INT STOP HUP

# Do the actual rebasing.
for branch in $branches; do
  ((verbose)) && echo Rebasing $branch on $upstream ...
  $cmd git rebase $@ $upstream $branch
  if (( $? != 0 && abort )) && [[ -z $cmd ]]; then
    ((verbose)) && echo Rebasing $branch on $upstream failed.  Aborting rebase.
    git rebase --abort
    ((retry)) && git retry-rebase -u $upstream -b $branch
  fi
done

# Check out the saved HEAD.
$cmd git checkout $head 2>/dev/null
