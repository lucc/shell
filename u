#!/bin/zsh

# This is a script to collect shell snippets until I develop them into real
# shell scripts.  "u" stands for "utils".  I got the idea from hans.

prog=${0##*/}

function assert () {
  "$@"
  local ret=$?
  if [[ $ret -ne 0 ]]; then
    echo "Failed to execute '$@'." >&2
    exit 3
  fi
}
function start-bluetooth () {
  if [[ $(systemctl is-active bluetooth) != active ]]; then
    echo Starting bluetooth service ...
    sudo systemctl start bluetooth
  fi
}

while getopts hx FLAG; do
  case $FLAG in
    h) set -- help; break;;
    x) set -x;;
  esac
done

shift $((OPTIND - 1))


if [[ $# -eq 0 ]]; then
  set -- help
fi

case $1 in
  help) # show this help message
    echo "$prog [options] subcommand [options] [arguments ...]"
    echo Possible subcommands are:
    #sed -n '/^case/,/^esac$/{s/^  \(.*\))\( *# *\(.*\)\)\{0,1\}$/\1 \3/p;}' $0
    sed -n '
      /^case/,/^esac$/{
        s/^  \([[:space:]]*(\{0,1\}[^()]*\))\( *# *\(.*\)\)\{0,1\}$/\1 \3/p
      }' $0 \
    | while read arg help; do
	printf '%s\t%s\n' $arg $help
      done
    ;;
  complete) # print setup code for completion (for eval-ing)
    # First define the completion function.  Avoid name colisions.
    function _lucs_util_scipt_completion_function () {
      local state
      # First handle global options.  Everything that does not match a global
      # option as defined here is handled later.  The $state is set to
      # "subcommand" in this case.
      _arguments \
	'(- *)-h[show help]' \
	'(-h -x)-x[debug output]' \
	':subcommand:->subcommand' \
	'*::options:->options' \
      && return 0
      case $state in
	subcommand)
	  local -a subcommands_array
	  subcommands_array=(
	    'help:show help'
	    'edit:open the script itself in $EDITOR'
	    'bk:mount the external backup hd and make a backup'
	    'phone:some phone related subcommands'
	    'export-abook-for-nokia:todo'
	    'split-file-at-empty-lines:split a text files into several files'
	    'backup:foo todo'
	    'urxvt-font:set the font in this urxvt'
	    'ycm-recompile:recompile the ycm plugin'
	    'logs:show different logs'
	    'setenv:set an environment var in a running process'
	    'bank:open the bank browser'
	    'python-profile:create a png from a python profileing run'
	    'test-vim-startup:mesure and sort nvim startup time'
	    'cmp-git-branch:run command on this branch and master (-u)'
	    'true-color-test:test true color support of the terminal'
	    'print:stage files for printing at the university (or --flush)'
	    'time-management:control the time management warnings'
	  )
	  # Use this array to complete the subcommands.
	  _describe -t subcommands 'util subcommands' subcommands_array \
	    && ret=0
	  ;;
	options)
	  # TODO what is this?
	  curcontext="${curcontext%:*}-${words[1]}:"
	  case $words[1] in
	    split-file-at-empty-lines) _arguments '*:: :_files';;
	    urxvt-font) _arguments '*:: :_x_fonts';; # doesn't work yet
	    export-abook-for-nokia) _arguments '*:: :_files';;
	    print)
	      _arguments \
		'--flush[flush the print queue now]:lp options:_u_helper_lp_options' \
		'*:: :_files';;
	    phone)
	      _arguments \
		':subcommand:->subcommand' \
		'*:: :_files'
	      subcommands_array=(
		put-vcf:'push contacts from a file to the phone'
		savecontacts:'backup all contacts from phone to a file'
	      )
	      [[ $state = subcommand ]] \
		&& _describe -t subcommands 'phone subcommands' subcommands_array \
		&& ret=0
	      ;;
	    logs)
	      _arguments ':subcommand:->subcommand' '*:: :_files'
	      subcommands_array=(
		{fetchmail,mailin,pop}:'logs for fetchmail'
		{smtp,mailout}:'logs for msmtp'
		{backup,bk}:'logs for different backup scripts'
	      )
	      [[ $state = subcommand ]] \
		&& _describe -t subcommands 'logs subcommands' subcommands_array \
		&& ret=0
	      ;;
	    time-management)
	      _arguments ':subcommand:->subcommand' '*:: :_files'
	      subcommands_array=(
		list:'list the timers'
		reset:'reset the timer'
		start:'start a timer'
		stop:'stop all timers'
		pause:'pause all timers'
		continue:'continue paused timers'
	      )
	      [[ $state = subcommand ]] \
		&& _describe -t subcommands 'time management subcommands' subcommands_array \
		&& ret=0
	      ;;
	  esac
	  ;;
	*) _message 'Error in completion function.';;
      esac
    }
    # Print the defined completion function and the setup code.
    functions _lucs_util_scipt_completion_function
    print compdef _lucs_util_scipt_completion_function $prog
    #sed -n '/^case/,/^esac$/{s/^  \(.*\))\( *# *\(.*\)\)\{0,1\}$/\1 \3/p;}' $0
    # Last define some helper functions
    function _u_helper_lp_options () {
      local service=lp
      _lp $@
    }
    functions _u_helper_lp_options
    ;;
  edit|e) # edit the source of this script
    # Use exec to suppress syntax errors if parsing continues after the file
    # was changed.
    exec $EDITOR $0
    ;;
  bk) # mount the backup hard disk and make a backup
    until
      findmnt /media/bak >/dev/null
    do
      echo Please plug in the external backup disk.
      sleep 1
      sudo mount LABEL=bak.fs
    done
    backup.py -v \
      snap \
      --exclude=/{.cache,tmp,vid,audio,img,comic,TV-'*'.webl.h264.mp4} \
      /media/bak/home
    ret=$?
    df -h /media/bak
    sudo umount /media/bak
    exit $ret
    ;;
  bk-mini)
    set -e
    myip=$(curl --silent http://luc42.lima-city.de/ip.php)
    piip=$(dig +short luc.now-dns.net)
    if [[ $myip = $piip ]]
    then domain=pi
    else domain=nowip
    fi
    backup.py -v snap \
      -s etc -s mail -s .config \
      -s uni --exclude=/uni/'[^si]*' \
      ${domain}:backup/tp/home
    ;;
  phone) # phone related subcommands
    shift
    case $1 in
      savecontacts)
	# check bluetooth service
	start-bluetooth
	echo Connecting to Nokia phone ...
	bluetoothctl <<-EOF
	power on
	connect 00:25:47:10:0D:2D
	exit
	EOF
	# Wait for the connection.
	sleep 1
	gammu backup $2.vcf <<<ALL
	;;
      put-vcf)
	start-bluetooth
	echo Connecting to Nokia phone ...
	bluetoothctl <<-EOF
	power on
	connect 00:25:47:10:0D:2D
	exit
	EOF
	# Wait for the connection.
	sleep 1
	tmp1=$(mktemp --suffix=.vcf)
	tmp2=$(mktemp --suffix=.vcf)
	sed '/^ADR[;:]/d' < $2 > $tmp1
	iconv -c --to-code=latin1 --output=$tmp2 $tmp1
	gammu restore $tmp2 <<<ALL
	rm -f $tmp1 $tmp2
	;;
      *)
	echo TODO >&2
	exit 2
	;;
    esac
    ;;
  export-abook-for-nokia)
    if [[ $# -ne 2 ]]; then
      echo You have to give a filename >&2
      exit 2
    fi
    #abook --convert --infile ~/.config/abook/addressbook --outformat vcard | \
    #  iconv --to-code latin1 > ${2%.vcf}.vcf
    tmp=$(mktemp)
    abook --convert --infile ~/.config/abook/addressbook --outformat vcard --outfile $tmp
    #vim -e -s -c 'set fileencoding=latin1' -c "saveas! ${2%.vcf}.vcf" -c 'quit!' $tmp
    vim -e -s --cmd "edit $tmp" --cmd 'set fileencoding=latin1' --cmd "saveas! ${2%.vcf}.vcf" --cmd 'quit!'
    rm $tmp
    echo Saved to ${2%.vcf}.vcf.
    ;;
  split-file-at-empty-lines)
    shift
    empty=''
    extension=.vcf
    while [[ $# -ge 1 ]]; do
      case $1 in
	--windows|--crlf|--dos)
	  empty=$'\r'
	  shift
	  ;;
	-d|--dir|--out|-o|--output)
	  if [[ $# -eq 1 ]]; then
	    echo The option $1 needs an argument. >&2
	    exit 2
	  fi
	  output=$2
	  shift 2
	  ;;
	--extension)
	  if [[ $# -eq 1 ]]; then
	    echo The option $1 needs an argument. >&2
	    exit 2
	  fi
	  extension=$2
	  shift 2
	  ;;
	--)
	  shift
	  break
	  ;;
	*)
	  break
	  ;;
      esac
    done
    if [[ $# -ne 1 ]]; then
      echo You need to give exactly one filename. >&2
      exit 2
    fi
    file=$1
    if [[ -z $output ]]; then
      output=$file.split
    fi
    # find the number of empty lines (corresponds to the number of files
    # created) and then count the bytes in the decimal representation, which
    # gives the length to which output filename numbers should be padded with
    # zeros
    length=$(($(echo $(($(grep --count "^$empty\$" $file) + 1)) | wc --bytes) - 1))
    integer -Z $length i=0
    mkdir -p $output
    rm -f $output/*(N)
    while read line; do
      if [[ $line = $empty ]]; then
	((i++))
	rm -f $output/$i$extension
      else
	echo $line >> $output/$i$extension
      fi
    done < $file
    ;;
  backup)
    backup.py snapshot --source ~/.config/gpg/ --exclude \
      $(repeat 14 printf '[0-9]') --exclude latest \
       nowip:backup/gpg
    backup.py snapshot --source $PASSWORD_STORE_DIR/ --exclude .git \
      --exclude .gitattributes \
      nowip:backup/pass
    ;;
  urxvt-font)
    printf '\33]50;%s\007' ${2:-xft:terminus};;
  ycm-recompile)
    cd ~/.local/share/nvim/plugins/YouCompleteMe
    git pull
    git submodule update --recursive
    case plain in
      system)
	# This was making trouble:
	# > The ycmd server SHUT DOWN (restart with ':YcmRestartServer').
	# > Unexpected error while loading the YCM core library. Run
	# > ':YcmToggleLogs stderr' to check the logs.
	python2 ./install.py \
	  --clang-completer --system-libclang --system-boost
	;;
      plain)
	# This was making troube because the libtinfo symlink to ncurses (from
	# AUR) is version 6 but ycm needs 5.
	python2 ./install.py --clang-completer
	;;
    esac
    ;;
  logs)
    shift
    case $1 in
      bk|backup)
	systemctl --no-pager --full status \
	  backup-pacman-cache.timer \
	  backup.py@-home-luc-.config-backup.py-arch.timer
	systemctl --no-pager --full --user status \
	  backup.py@-home-luc-.config-backup.py-home.timer
	echo "==============================================================="
	systemctl --no-pager --full status \
	  backup-pacman-cache.service \
	  backup.py@-home-luc-.config-backup.py-arch.service
	systemctl --no-pager --full --user status \
	  backup.py@-home-luc-.config-backup.py-home.service
	;;
      pop|mailin|fetchmail)
	journalctl --quiet --no-pager --lines=$((2*LINES)) \
	  --user-unit=fetchmail.service
	;;
      smtp|mailout)
	journalctl --quiet --no-pager --lines=$((2*LINES)) \
	  SYSLOG_IDENTIFIER=msmtp
	;;
      mail|mailall|allmail)
	journalctl --quiet --no-pager --lines=$((2*LINES)) \
	  SYSLOG_IDENTIFIER=msmtp + _SYSTEMD_USER_UNIT=fetchmail.service
	;;
      *) print Choose one of bk, pop or smtp. >&2; exit 2;;
    esac
    ;;
  setenv) # <PID> VARNAME=value
    shift
    # thanks to https://gist.github.com/coderofsalvation/e1376e4d2b29607431df
    sudo gdb -q -batch -ex "attach $1" -ex "call putenv(\"$2\")" -ex 'detach'
    ;;
  bank)
    shift
    browser -b \
      https://www.onlinebanking-vr-ll.de/banking-private/entry \
      https://banking.umweltbank.de/ $@ &
    ;;
  python-profile)
    shift
    name=profile
    while getopts n: FLAG; do
      case $FLAG in
	n) name=$OPTARG;;
      esac
    done
    shift $((OPTIND - 1))
    PYTHONPATH=. python -m cProfile -o $name.pstats $@
    gprof2dot -f pstats $name.pstats > $name.dot
    dot -T png -o $name.png $name.dot
    feh $name.png
    ;;
  test-vim-startup)
    shift
    searchterm=${1:-sourcing}
    nvim --headless -c 'quitall!' --startuptime \
      >(grep ${@:-sourcing} | sort -n --key=3) \
      2>/dev/null
    ;;
  cmp-git-branch)
    shift
    upsteam=master
    count=10
    while getopts u:c: FLAG; do
      case $FLAG in
	u) upstream=$OPTARG;;
	c) count=$OPTARG;;
      esac
    done
    shift $((OPTIND - 1))
    # Save the current HEAD.
    head=$(git rev-parse --abbrev-ref HEAD)
    time (for i in {0..$count}; do $@ &>/dev/null; done )
    git checkout $upstream
    time (for i in {0..$count}; do $@ &>/dev/null; done )
    git checkout $head
    ;;
  true-color-test) # print some colors to test true color support of the term
    awk 'BEGIN{
    s="/\\/\\/\\/\\/\\"; s=s s s s s s s s;
    for (colnum = 0; colnum<77; colnum++) {
      r = 255-(colnum*255/76);
      g = (colnum*510/76);
      b = (colnum*255/76);
      if (g>255) g = 510-g;
	printf "\033[48;2;%d;%d;%dm", r,g,b;
	printf "\033[38;2;%d;%d;%dm", 255-r,255-g,255-b;
	printf "%s\033[0m", substr(s,colnum+1,1);
      }
      printf "\n";
    }'
    ;;
  print)
    shift
    if [[ $1 = --flush ]]; then
      shift
      ssh ifi bin/flush-print-queue.sh $@
    else
      scp -p $@ ifi:print/
    fi
    ;;
  time-management)
    shift
    case $1 in
      list)
	systemctl --user list-timers | grep time-management-warning@
	;;
      reset)
	systemctl --user start time-management-warning
	;;
      start)
	if [[ -z $2 ]]; then
	  echo You have to give a time argument. >&2
	  exit 2
	fi
	systemctl --user start time-management-warning@$2.timer
	;;
      stop)
	;;
      pause)
	;;
      continue)
	;;
      *)
	;;
    esac
    ;;
  show-term-attributes)
    for i in {0..15}; do
      printf 'i=%-3s --[\e[%sm terminal code test string \e[0m]--\n' $i: $i
    done
    ;;
  updateinfo)
    pacman -Qquet | xargs pacman -Qi | \
      sed -E '/(^(Version|Architecture|Licenses|Packager|Build Date|Install Date|Install Reason|Install Script|Validated By)|None$)/d; s/^Name.*/\x1b[31m&\x1b[m/'
esac
